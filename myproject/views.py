from datetime import timezone
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required

import openai
from django.conf import settings
import json

from myapp.models import Quiz, QuizAttempt, Category, SubCategory

from django.db.models import Sum, Count, Avg

openai.api_key = settings.OPENAI_API_KEY


def login_view(request):
    if(request.method =='POST'):
        username = request.POST['username']
        password = request.POST['password']
        user = authenticate(request, username=username, password=password)

        if user is not None:
            login(request, user)
            return redirect('home')
        else:
            return render(request, 'login.html',{'error': 'Invalid cred'})
        
    return render(request, 'login.html')
    # return render(request, 'home.html')

def signup_view(request):
    if request.method ==  'POST':
        username = request.POST['username']
        password = request.POST['password']
        if User.objects.filter(username=username).exists():
            return render(request, 'signup.html', {'error':'username already exits'})
        
        user = User.objects.create_user(username=username, password=password)
        user.save()
        return redirect('login')
    return render(request, 'signup.html')

def home_view(request):
    user = request.user
    categories = Category.objects.prefetch_related("subcategories").all()
    # return render(request, "home.html", {"categories": categories})
    return render(request, 'home.html', {'user':user, 'categories':categories})

@login_required
def edit_profile_view(request):
   if request.method == "POST":
       user = request.user
       profile = user.profile

       email = request.POST.get("email")
       bio = request.POST.get("bio")
       avatar = request.FILES.get("avatar")

       if email:
           user.email = email
           user.save()
        
       if bio is not None:
           profile.bio = bio

       if avatar:
           profile.avatar = avatar
       profile.save()

       return redirect("home")
   return render(request, "myapp/home.html", {"user":user})

def logout_view(request):
    logout(request)
    return redirect('login')

def start_quiz_view(request):
    if request.method == "POST":
        category_id = request.POST.get('category')
        subcategory_id = request.POST.get('subcategory')
        difficulty = request.POST.get('difficulty')

        try:
            category = Category.objects.get(pk=category_id)
            subcategory = category.subcategories.get(pk=subcategory_id)
        except (Category.DoesNotExist, SubCategory.DoesNotExist):
            return render(request, 'quiz.html', {'error': 'Invalid category or subcategory'})

        # reference = "https://www.geeksforgeeks.org/dbms/structural-constraints-of-relationships-in-er-model/"

        # Prompt OpenAI to generate questions
        system_prompt = f"""Hey, you are expert in {category.name} and {subcategory.name}. You have to generate quiz of {category.name}
        and {subcategory.name} so that student can learn and practice this subject 
            and also do not repeat
            the questions in the quiz"""

        prompt = f"""
        Generate 5 multiple-choice quiz questions in JSON format.
        Category: {category.name}
        Subcategory: {subcategory.name}
        Difficulty: {difficulty}
        Each question must have:
        - "question": string
        - "options": list of 4 strings
        - "answer": the correct option text
        Example:
        [
            {{
            "question": "What is the capital of India?",
            "options": ["Delhi", "Kanpur", "Pune", "Kolkata"],
            "answer": "Delhi"
            }}
        ]
        """

        # if reference:
        #     prompt += f" Use the following reference: {reference}."

        response = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": prompt}],
            max_tokens=500,
            temperature=0.8
        )
       

        try:
            questions = json.loads(response.choices[0].message.content.strip())
        except Exception:
            questions = []

        quiz = Quiz.objects.create(
            title=f"{category.name} Quiz",
            description=f"Quiz generated by OpenAI - Category: {category.name}, Subcategory: {subcategory.name}, Difficulty: {difficulty}",
        )
        quiz.questions = questions  # Assign questions after creation
        quiz.save()

        quiz_attempt = QuizAttempt.objects.create(user=request.user, quiz=quiz)
        request.session['quiz_attempt_id'] = quiz_attempt.id

        return render(request, "quiz.html", {"questions": questions, "submitted": False})

    return render(request, "quiz.html", {"show_modal": True, "submitted": False})

def submit_quiz_view(request):
    if request.method == "POST":
        quiz_attempt_id = request.session.get('quiz_attempt_id')
        quiz_attempt = QuizAttempt.objects.get(pk=quiz_attempt_id)
        quiz = quiz_attempt.quiz
        questions = quiz.questions
        score = 0
        total_questions = len(questions)

        for i, question in enumerate(questions):
            selected_answer = request.POST.get(f"question{i+1}")
            if selected_answer == question['answer']:
                score += 1

        quiz_attempt.score = score
        quiz_attempt.save()

        return render(request, 'scoreCard.html', {'score': score, 'total': total_questions})
    return redirect('home')

def retake_quiz_view(request):
    quiz_attempt_id = request.session.get('quiz_attempt_id')
    quiz_attempt = QuizAttempt.objects.get(pk=quiz_attempt_id)
    quiz = quiz_attempt.quiz

    # Create a new QuizAttempt for the retake
    new_quiz_attempt = QuizAttempt.objects.create(user=request.user, quiz=quiz)
    request.session['quiz_attempt_id'] = new_quiz_attempt.id

    questions = quiz.questions
    return render(request, "quiz.html", {"questions": questions, "submitted": False})

def create_quiz_view(request):
    return None


def dashboard_view(request):
    user = request.user
    total_score = QuizAttempt.objects.filter(user=user).aggregate(total=Sum("score"))["total"] or 0
    total_quizzes = QuizAttempt.objects.filter(user=user).count()
    avg_score = QuizAttempt.objects.filter(user=user).aggregate(avg=Avg("score"))["avg"] or 0

    # Recent 10 attempts
    recent_quizzes = QuizAttempt.objects.filter(user=user).select_related("quiz").order_by("-completed_at")[:10]

    return render(request, "dashboard.html", {
        "total_score": total_score,
        "total_quizzes": total_quizzes,
        "avg_score": round(avg_score, 2),
        "recent_quizzes": recent_quizzes,
    })

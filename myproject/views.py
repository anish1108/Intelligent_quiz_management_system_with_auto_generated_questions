# from datetime import timezone
from django.utils import timezone
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required

import openai
from django.conf import settings
import json

from myapp.models import Quiz, QuizAttempt, Category, SubCategory

from django.db.models import Sum, Count, Avg

openai.api_key = settings.OPENAI_API_KEY


def login_view(request):
    if(request.method =='POST'):
        username = request.POST['username']
        password = request.POST['password']
        user = authenticate(request, username=username, password=password)

        if user is not None:
            login(request, user)
            return redirect('home')
        else:
            return render(request, 'login.html',{'error': 'Invalid cred'})
        
    return render(request, 'login.html')
    # return render(request, 'home.html')

def signup_view(request):
    if request.method ==  'POST':
        username = request.POST['username']
        password = request.POST['password']
        if User.objects.filter(username=username).exists():
            return render(request, 'signup.html', {'error':'username already exits'})
        
        user = User.objects.create_user(username=username, password=password)
        user.save()
        return redirect('login')
    return render(request, 'signup.html')

def home_view(request):
    user = request.user
    categories = Category.objects.prefetch_related("subcategories").all()
    # return render(request, "home.html", {"categories": categories})
    return render(request, 'home.html', {'user':user, 'categories':categories})

@login_required
def edit_profile_view(request):
   if request.method == "POST":
       user = request.user
       profile = user.profile

       email = request.POST.get("email")
       bio = request.POST.get("bio")
       avatar = request.FILES.get("avatar")

       if email:
           user.email = email
           user.save()
        
       if bio is not None:
           profile.bio = bio

       if avatar:
           profile.avatar = avatar
       profile.save()

       return redirect("home")
   return render(request, "myapp/home.html", {"user":user})

def logout_view(request):
    logout(request)
    return redirect('login')
@login_required
def start_quiz_view(request):
    if request.method == "POST":
        category_id = request.POST.get('category')
        subcategory_id = request.POST.get('subcategory')
        difficulty = request.POST.get('difficulty')

        try:
            category = Category.objects.get(pk=category_id)
            subcategory = category.subcategories.get(pk=subcategory_id)
        except (Category.DoesNotExist, SubCategory.DoesNotExist):
            return render(request, 'quiz.html', {'error': 'Invalid category or subcategory'})

        # reference = "https://www.geeksforgeeks.org/dbms/structural-constraints-of-relationships-in-er-model/"

        # Prompt OpenAI to generate questions
        system_prompt = f"""Hey, you are expert in {category.name} and {subcategory.name}. You have to generate quiz of {category.name}
        and {subcategory.name} so that student can learn and practice this subject 
            and also do not repeat
            the questions in the quiz"""

        prompt = f"""
        Generate 5 multiple-choice quiz questions in JSON format.
        Category: {category.name}
        Subcategory: {subcategory.name}
        Difficulty: {difficulty}
        Each question must have:
        - "question": string
        - "options": list of 4 strings
        - "answer": the correct option text
        - "explanation": a short explanation of why that answer is correct
        - it should not in the list of this recent questions 
        Example:
        [
            {{
            "question": "What is the capital of India?",
            "options": ["Delhi", "Kanpur", "Pune", "Kolkata"],
            "answer": "Delhi"
            }}
        ]
        """

        # if reference:
        #     prompt += f" Use the following reference: {reference}."

        response = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": prompt}],
            max_tokens=500,
            temperature=1
        )
       

        try:
            questions = json.loads(response.choices[0].message.content.strip())
        except Exception:
            questions = []

        quiz = Quiz.objects.create(
            title=f"{category.name} Quiz",
            description=f"Quiz generated by OpenAI - Category: {category.name}, Subcategory: {subcategory.name}, Difficulty: {difficulty}",
        )
        quiz.questions = questions  # Assign questions after creation
        quiz.save()

        quiz_attempt = QuizAttempt.objects.create(user=request.user, quiz=quiz)
        request.session['quiz_attempt_id'] = quiz_attempt.id

        return render(request, "quiz.html", {"questions": questions, "submitted": False})

    return render(request, "quiz.html", {"show_modal": True, "submitted": False})

def submit_quiz_view(request):
    if request.method == "POST":
        quiz_attempt_id = request.session.get('quiz_attempt_id')
        quiz_attempt = QuizAttempt.objects.get(pk=quiz_attempt_id)
        quiz = quiz_attempt.quiz
        questions = quiz.questions
        score = 0
        total_questions = len(questions)

        results = []
        correct_streak = 0
        max_correct_streak = 0  # for in-quiz streak

        for i, question in enumerate(questions):
            selected_answer = request.POST.get(f"question{i+1}")
            is_correct = selected_answer == question['answer']

            if is_correct:
                score += 1
                correct_streak += 1
                max_correct_streak = max(max_correct_streak, correct_streak)
            else:
                correct_streak = 0  # reset in-quiz streak

            results.append({
                "question": question['question'],
                "selected_answer": selected_answer or "No answer selected",
                "correct_answer": question['answer'],
                "explanation": question.get("explanation", "Explanation not available."),
                "is_correct": is_correct
            })

        quiz_attempt.score = score
        quiz_attempt.completed_at = timezone.now()
        quiz_attempt.save()

        # ðŸ†• Update streak
        profile = request.user.profile
        profile.update_streak()

        return render(request, 'scoreCard.html', {
            'score': score,
            'total': total_questions,
            'results': results,
            'quiz_id': quiz.id,
            'daily_streak': profile.daily_streak,
            'max_streak': max_correct_streak,  # show in-quiz streak
        })

    return redirect('home')


def retake_quiz_view(request):
    quiz_attempt_id = request.session.get('quiz_attempt_id')
    quiz_attempt = QuizAttempt.objects.get(pk=quiz_attempt_id)
    quiz = quiz_attempt.quiz

    # Create a new QuizAttempt for the retake
    new_quiz_attempt = QuizAttempt.objects.create(user=request.user, quiz=quiz)
    request.session['quiz_attempt_id'] = new_quiz_attempt.id

    questions = quiz.questions
    return render(request, "quiz.html", {"questions": questions, "submitted": False})

def create_quiz_view(request):
    return None


@login_required
def dashboard_view(request):
    user = request.user
    profile = user.profile

    # Fetch last 10 attempts, ordered by most recent start time
    recent_quizzes = (
        QuizAttempt.objects.filter(user=user)
        .select_related('quiz')
        .order_by('-started_at')[:10]
    )

    leaderboard = (
        QuizAttempt.objects.values('user__username')
        .annotate(total_score=Sum('score'))
        .order_by('-total_score')[:10]
    )

    context = {
        'profile': profile,
        'recent_quizzes': recent_quizzes,
        'leaderboard': [
            {'name': u['user__username'], 'total_score': u['total_score']}
            for u in leaderboard
        ],
        'total_score': sum(q.score for q in recent_quizzes),
        'total_quizzes': recent_quizzes.count(),
        'avg_score': round(
            sum(q.score for q in recent_quizzes) / recent_quizzes.count(), 2
        ) if recent_quizzes else 0,
    }
    return render(request, 'dashboard.html', context)


@login_required
def resume_quiz(request, quiz_id):
    quiz = get_object_or_404(Quiz, id=quiz_id)
    attempt = QuizAttempt.objects.filter(
        user=request.user, quiz=quiz, completed_at__isnull=True
    ).last()

    if not attempt:
        attempt = QuizAttempt.objects.create(user=request.user, quiz=quiz)

    request.session['quiz_attempt_id'] = attempt.id
    questions = quiz.questions
    return render(request, "quiz.html", {"questions": questions, "submitted": False})

